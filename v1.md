# Auth Service Architecture Specification

## Overview

Standalone authentication microservice responsible for identity, token
issuance, session management, and credential validation. Designed as an
internal authentication authority similar in role to Auth0 but
self-hosted and fully controllable.

---

## Repository Structure

```text
auth-service/
|-- app/
|   |-- main.py                  # App factory, middleware registration, router inclusion only
|   |-- config.py                # All settings via pydantic-settings
|   |-- dependencies.py          # Shared FastAPI dependencies
|   |-- middleware/
|   |   |-- correlation_id.py
|   |   |-- logging.py
|   |   |-- rate_limit.py
|   |   |-- security_headers.py
|   |   `-- tracing.py
|   |-- routers/
|   |   |-- auth.py              # Login, logout, refresh
|   |   |-- oauth.py             # OAuth2 / OIDC flows
|   |   |-- saml.py              # SAML flows
|   |   |-- apikeys.py           # API key management
|   |   `-- health.py
|   |-- core/
|   |   |-- jwt.py
|   |   |-- oauth.py
|   |   |-- saml.py
|   |   |-- api_keys.py
|   |   `-- sessions.py
|   |-- models/
|   |   |-- user.py
|   |   |-- session.py
|   |   `-- api_key.py
|   |-- schemas/
|   |   |-- token.py
|   |   |-- user.py
|   |   `-- api_key.py
|   |-- db/
|   |   |-- base.py
|   |   `-- session.py
|   `-- services/
|       |-- user_service.py
|       |-- token_service.py
|       `-- audit_service.py
|-- sdk/                         # Separate pip package: auth-service-sdk
|   |-- __init__.py
|   |-- client.py
|   |-- middleware.py
|   |-- exceptions.py
|   |-- types.py
|   `-- cache.py
|-- migrations/                  # Alembic
|-- tests/
|   |-- unit/
|   `-- integration/
|-- docker/
|   |-- Dockerfile
|   `-- docker-compose.yml
|-- k8s/
|   |-- deployment.yaml
|   |-- service.yaml
|   |-- ingress.yaml
|   |-- secrets.yaml
|   `-- hpa.yaml
`-- pyproject.toml
```

---

## Core Stack

- Python 3.11
- FastAPI + Uvicorn
- SQLAlchemy Async + asyncpg
- Postgres
- Redis (sessions, blocklist, OAuth state, rate limiting)
- Authlib (OAuth2 / OIDC client)
- python-jose (JWT)
- python3-saml (SAML 2.0)
- passlib + bcrypt (password hashing)
- OpenTelemetry
- Prometheus + prometheus-fastapi-instrumentator
- structlog

---

## Implementation Plan

The steps below are ordered by dependency. Each step states what to build,
what constraints apply, and what done looks like. Do not start a step until
all steps it depends on are complete.

---

### Step 1 — Project Scaffold and Configuration

**What to build:**

Create the full directory structure as defined in the Repository Structure
section above. Initialize `pyproject.toml` with all dependencies pinned.
Implement `app/config.py` as the single source of all configuration using
`pydantic-settings`. Configure `structlog` for JSON output with the required
fields. Set up `ruff` and `black` in `pyproject.toml`.

**Constraints:**

- `app/config.py` is the only place settings are defined. No `os.getenv()`
  anywhere else in the codebase, ever.
- All secrets (JWT private key, DB URL, Redis URL, Google client secret,
  SAML certificates) must come from environment variables or mounted
  Kubernetes Secrets. No hardcoded values.
- Every log entry must include `correlation_id`, `environment`, `service`,
  `level`, and `timestamp` (ISO 8601, UTC). Configure structlog processors
  at this step so all subsequent steps inherit the correct format.
- Use Python 3.11+. Type hints on every function signature.

**Config groups to cover:**

App identity, database URL (asyncpg), Redis URL, JWT keys (RS256 PEM pair,
injected as secrets), access token TTL (15 minutes), refresh token TTL (7
days), Google OAuth client ID and secret, redirect URIs and allowlist, SAML
SP and IdP config, rate limit thresholds.

**Done when:**

`app/config.py` loads and validates from environment variables. Running the
app with missing required env vars raises a clear validation error. `ruff`
and `black` pass with zero errors on all files committed so far.

---

### Step 2 — Database Layer and Models

**What to build:**

Implement async SQLAlchemy setup in `app/db/base.py` and `app/db/session.py`
using `asyncpg`. Define all ORM models in `app/models/`. Initialize Alembic
and generate the first migration covering all tables.

**Tables to implement:**

`users` — canonical identity record, one row per human regardless of auth
provider.

`user_identities` — links a user to an external provider (google, saml,
password). One user can have multiple identities.

`sessions` — server-side session ledger. Columns: `session_id` (UUID, stable
across all rotations, primary key), `user_id`, `hashed_refresh_token`
(sha256 of raw token, updated on every rotation), `expires_at`, `revoked_at`
(null until logout or forced revocation).

`api_keys` — stores `sha256(raw_key)`, `key_prefix` (first 8 characters for
display), `scope`, `expires_at`, `revoked_at`.

**Constraints:**

- Every table must have `id` (UUID, default generated), `created_at`,
  `updated_at`, `deleted_at` (nullable, for soft deletes), and `tenant_id`
  (UUID, nullable, reserved for v2).
- Never use `create_all()` in any production code path. All schema changes go
  through Alembic migrations only.
- Never use synchronous DB calls. All queries must be `async`/`await`.
- Never hard-delete any row. Always soft-delete via `deleted_at`.
- Always filter soft-deleted records in queries (`WHERE deleted_at IS NULL`).
- Never write raw SQL strings. Use SQLAlchemy ORM or Core expression language.

**Done when:**

`alembic upgrade head` creates all tables cleanly against a fresh Postgres
instance. Models are importable. Async session factory works. No `create_all()`
exists anywhere in the codebase.

---

### Step 3 — Password Auth, User Service, and JWT Issuance

**What to build:**

Implement `app/core/jwt.py` for RS256 token issuance and verification.
Implement `app/services/user_service.py` for user lookup and password
validation. Implement `app/services/token_service.py` for access token and
refresh token generation. Implement `app/routers/auth.py` for the login
endpoint only (refresh and logout come in step 4). Expose
`GET /.well-known/jwks.json` as a public, unauthenticated endpoint.

**JWT rules:**

- Algorithm: RS256 only. HS256 must not exist anywhere in the codebase.
- Access token lifetime: 15 minutes.
- Refresh token lifetime: 7 days.
- Every JWT must include `jti` (UUID), `iat`, `exp`, `sub` (user ID),
  `type` (`access` or `refresh`).
- The JWKS endpoint must always be public and unauthenticated.

**Password rules:**

- Never store plaintext passwords. Use `passlib` with `bcrypt`.
- Always use `hmac.compare_digest()` for comparisons. Never `==`.

**Logging rules:**

- Log every login attempt as a structured auth event including `event_type`,
  `user_id` (if known), `provider`, `ip_address`, `success` (bool).
- Never log passwords, tokens, or any credential material.
- Log all auth failures at WARNING level with correlation ID and user
  identifier if known.

**Error handling:**

- Invalid credentials map to 401 with code `invalid_credentials`.
- All error responses follow the shape:
  `{"detail": "<human readable>", "code": "<machine readable>"}`.
- Never return stack traces to the client in production.

**Done when:**

`POST /auth/login` with valid credentials returns an access token and a
refresh token. `GET /.well-known/jwks.json` returns the public key in JWKS
format. Unit tests in `tests/unit/` cover `app/core/jwt.py` and
`app/services/user_service.py` including failure paths.

---

### Step 4 — Redis Sessions, Refresh Token Rotation, and Logout

**What to build:**

Implement `app/core/sessions.py` for Redis session management. Implement
the refresh endpoint and logout endpoint in `app/routers/auth.py`. Wire
session creation into the login flow from step 3.

**Session model — exact rules:**

The DB `sessions` table is the authoritative record. Redis is a performance
cache. They serve different purposes and must not be conflated. Session
rebuild from DB inline during auth is never permitted.

Redis stores session payload only, keyed by `session_id` (not by token
hash): key `session:{session_id}`, value `{ user_id, email, scopes,
issued_at }`, TTL equal to `refresh_token_ttl_seconds`.

The raw refresh token never touches Redis. Redis holds no token material.

**Refresh flow — exact sequence:**

1. Hash the incoming raw token: `sha256(raw_token)`.
2. Look up `hashed_refresh_token` in DB to find the session record.
3. Validate `expires_at` and `revoked_at` on the DB record before touching
   Redis.
4. Use `session_id` from the DB record to fetch session payload from Redis.
5. If the Redis key is missing, fail closed with `session_expired`. Do not
   fall back to DB-only. Do not attempt inline rebuild.
6. Rotate: generate a new raw token, update `hashed_refresh_token` in DB,
   reset Redis TTL.
7. Return new access token and new refresh token.

**Logout flow:**

Delete the Redis key and set `revoked_at` on the DB session. Use a
transactional wrapper that rolls back the DB write if the Redis delete
fails. Add the access token `jti` to the Redis blocklist under key
`blocklist:jti:{jti}` with TTL equal to the token's remaining lifetime.

**Session creation rules:**

Session records are created only for user-login flows (password, OAuth,
SAML). API key identity flows are sessionless by design and must never
create session records.

`session_id` is generated once at login and never changes. It is never
exposed to the client. The client holds only the raw refresh token.

**Failure behavior:**

If Redis is unavailable, fail closed on all session-dependent operations.
Never silently fall back to DB-only session validation.

**Done when:**

Token refresh returns a new access token and rotates the refresh token.
Old refresh token is invalidated. Logout deletes Redis key and sets
`revoked_at`. If Redis is down, refresh and logout fail with an appropriate
error. Unit tests cover session creation, rotation, revocation, and
fail-closed behavior on Redis unavailability.

---

### Step 5 — Google OAuth2 / OIDC Flow

**What to build:**

Implement `app/core/oauth.py` using `authlib` for all OAuth2 client
operations. Implement `app/routers/oauth.py` with the login initiation
and callback endpoints. Implement the `user_identities` upsert flow.

**Constraints:**

- Use `authlib` for all OAuth2 client operations. Never implement token
  exchange or PKCE manually.
- Always verify the `id_token` signature from Google using their public
  JWKS. Never skip this step.
- Never trust the `email` from an OAuth provider without checking
  `email_verified: true` in the claims.
- Always validate `redirect_uri` against the stored allowlist before
  initiating or completing any OAuth flow.
- Never store OAuth `state` or `nonce` in cookies. `SameSite=Strict`
  cookies are not sent on cross-site redirect callbacks.

**State storage model:**

On login: generate `state` and `nonce`, store in Redis under key
`oauth_state:{state}` with TTL of 10 minutes, redirect to Google with
`state` and `nonce` in the authorization URL.

On callback: look up `oauth_state:{state}` in Redis. Reject with
`oauth_state_mismatch` if missing or expired. Delete the key immediately
after reading (one-time use only). Proceed with token exchange.

**Identity resolution:**

After token exchange, upsert into `user_identities` first, then resolve or
create the canonical `users` record. After successful identity resolution,
create a session record and issue tokens using the same flow as password
login.

**Done when:**

A browser-based OAuth login with Google results in a session, access token,
and refresh token. The callback correctly rejects replayed or missing state
values. `email_verified: false` claims are rejected. Integration tests cover
the full callback flow including state mismatch rejection.

---

### Step 6 — API Key System

**What to build:**

Implement `app/core/api_keys.py` for key generation, hashing, and
verification. Implement `app/routers/apikeys.py` for key creation, listing,
and revocation. Implement `POST /auth/introspect` for SDK consumption.

**Key format:** `sk_{secrets.token_urlsafe(32)}`

**Storage rules:**

- Store `sha256(raw_key)` in DB. Never store the raw key.
- Store the first 8 characters of the raw key as `key_prefix` for display.
- Return the raw key only once at creation time, never again.
- Always use `hmac.compare_digest()` for comparisons. Never `==`.

**Required fields:**

Every key must have a `scope` field. Never issue an unscoped key. Keys have
an optional `expires_at` field. Expired keys must be rejected even if
otherwise valid.

**Introspection endpoint contract (`POST /auth/introspect`):**

On success:
`{ "valid": true, "user_id": "...", "scopes": [...], "key_id": "...", "expires_at": "..." }`

On failure:
`{ "valid": false, "code": "invalid_api_key" | "expired_api_key" | "revoked_api_key" }`

**Sessionless identity:**

API key verification must never create a session record. API key identity
flows are sessionless by design.

**Done when:**

Key creation returns the raw key exactly once. Subsequent introspection with
that key returns the valid payload. Expired and revoked keys return the
correct failure codes. Unit tests cover all failure paths including expired
and revoked states. Integration tests cover the introspection endpoint.

---

### Step 7 — SAML 2.0 Flow

**What to build:**

Implement `app/core/saml.py` using `python3-saml` for all SAML operations.
Implement `app/routers/saml.py` with the AuthnRequest initiation, callback,
and SP metadata endpoints.

**Constraints:**

- Use `python3-saml` for all SAML operations. Never parse SAMLResponse XML
  manually.
- Always validate the assertion signature, conditions, and audience
  restriction.
- Never trust user-supplied input in SAML assertions without signature
  validation.
- Expose SP metadata at `GET /auth/saml/metadata`. Keep it up to date with
  the current certificate.

**Identity resolution:**

After successful SAML assertion validation, apply the same upsert flow as
OAuth via `user_identities`. Then resolve or create the canonical `users`
record and issue a session and tokens identical to the OAuth post-callback
flow.

**Done when:**

A SAML login against a test IdP completes and issues tokens. An assertion
with an invalid signature is rejected. SP metadata is accessible and
contains the current certificate. Unit tests cover signature validation
failure and malformed assertion cases.

---

### Step 8 — Middleware Stack

**What to build:**

Implement all five middleware modules in `app/middleware/`. Register them in
`app/main.py` in the exact order specified below.

**Execution order (outermost to innermost):**

1. Correlation ID — must be outermost. Every layer below depends on the
   request-scoped correlation ID being present.
2. Prometheus metrics — outside rate limiting so it counts 100% of traffic
   including rejected requests.
3. Security headers (CSP, X-Frame-Options, X-Content-Type-Options,
   Strict-Transport-Security) — outside rate limiting so that 429, 401, and
   500 responses all carry the correct headers.
4. Structured logging — wraps rate limiting so that rate limit rejections are
   logged with their outcome. Depends on correlation ID from step 1 already
   being attached.
5. Rate limiting (Redis sliding window, stricter limits on `/auth/login` and
   `/auth/token`) — rejects bad traffic before expensive downstream work,
   but sits inside logging so rejections are captured.
6. OpenTelemetry tracing — must be innermost so traces measure actual handler
   execution time only.

**Registration order in `main.py` (reverse of execution order, per Starlette
behavior):**

```python
app.add_middleware(TracingMiddleware)        # innermost, registered first
app.add_middleware(RateLimitMiddleware)
app.add_middleware(LoggingMiddleware)
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(MetricsMiddleware)
app.add_middleware(CorrelationIdMiddleware)  # outermost, registered last
```

**Constraints:**

- Never add business logic inside middleware. Middleware is for cross-cutting
  concerns only.
- The logging middleware must redact all credential material (tokens,
  passwords, API keys) before writing any log entry.
- All cookies set anywhere in the service must use `Secure=True`,
  `HttpOnly=True`, `SameSite=Strict`.

**Done when:**

Every response carries a correlation ID header and the full set of security
headers. Rate limiting rejects excess requests to `/auth/login` with a 429
and code `rate_limited`. Prometheus metrics endpoint shows request counts
including rejected ones. Tracing spans reflect handler time only.
Integration tests verify header presence on 4xx and 5xx responses.

---

### Step 9 — Health Endpoints and Error Handling

**What to build:**

Implement `app/routers/health.py` with liveness and readiness probes.
Implement a global exception handler in `app/main.py` that enforces the
error response shape.

**Health endpoints:**

`GET /health/live` — returns 200 if the process is running.

`GET /health/ready` — returns 200 only if both Postgres and Redis are
reachable. Returns 503 otherwise. This endpoint is used as the Kubernetes
readiness probe.

**Error handling rules:**

- Never return stack traces or internal error details to the client when
  `environment != "development"`.
- All error responses must follow this exact shape:
  `{"detail": "<human readable message>", "code": "<machine readable code>"}`.
- Valid error codes: `invalid_token`, `token_expired`, `invalid_api_key`,
  `expired_api_key`, `revoked_api_key`, `invalid_credentials`,
  `rate_limited`, `saml_assertion_invalid`, `oauth_state_mismatch`,
  `session_expired`.
- Never raise a 500 for an expected auth failure. Map all known failure cases
  to 4xx explicitly.
- Log all auth failures at WARNING level with correlation ID and user
  identifier if known.

**Done when:**

`/health/live` always returns 200. `/health/ready` returns 503 when Postgres
or Redis is unreachable. All error responses from all endpoints conform to
the required shape. Integration tests verify readiness probe behavior with
each backing service down independently.

---

### Step 10 — SDK Package

**What to build:**

Implement the `sdk/` package as a standalone pip package named
`auth-service-sdk`. The SDK must not import anything from `app/`. It
communicates only via the service's public HTTP API.

**Allowed runtime dependencies:** `httpx`, `python-jose`, `cachetools`,
`starlette` only.

**Build sequence:**

First, implement `sdk/types.py` with the type-discriminated user object:

- `type: "user"` — `{ type, user_id, email (required), scopes }`
- `type: "api_key"` — `{ type, key_id, service, scopes, email: None }`

`email` is required when `type == "user"` and must be absent or None when
`type == "api_key"`. Consuming services must check `type == "user"` before
accessing `email`.

Second, implement `sdk/cache.py` with the JWKS cache manager. Cache TTL is
5 minutes. On JWT verification failure, force one refresh attempt before
final rejection.

Third, implement `sdk/client.py` as `AuthClient`, an async `httpx` client
with sane timeouts. Expose at minimum `fetch_jwks()` and
`introspect_api_key()`.

Fourth, implement `sdk/middleware.py` with both middleware classes.

**JWTAuthMiddleware rules:**

- Verification is local using the cached public key. No network call per
  request.
- Refresh the cached public key from JWKS at most once every 5 minutes and
  on verification failure.
- Validate claims: `jti`, `exp`, `iat`, `sub`, `type`.
- Inject the documented `request.state.user` shape on success.

**APIKeyAuthMiddleware rules:**

1. Hash the raw key on arrival: `sha256(raw_key)`. Never hold the raw key
   beyond this step.
2. Check `cachetools.TTLCache` keyed by `sha256(raw_key)`. On hit, use
   cached result. No network call.
3. On miss: call `POST /auth/introspect` with the raw key.
4. Cache valid results for 60 seconds keyed by `sha256(raw_key)`.
5. Cache invalid results for 10 seconds to prevent hammering the auth
   service with bad keys.
6. On valid result: inject `request.state.user` and continue.
7. On invalid result: return 401 immediately.
8. If the auth service is unreachable: return 503. Never return 401 for a
   transient failure. Never fall back to a stale cache entry.

A revoked key may remain valid on a given service instance for up to 60
seconds. This is an accepted and documented tradeoff. The operational
response to immediate revocation is key deletion at the source, not cache
invalidation.

**Done when:**

`JWTAuthMiddleware` verifies tokens locally with correct JWKS cache refresh
behavior. `APIKeyAuthMiddleware` introspects on cache miss and caches
results with the correct TTLs. Both middlewares inject the documented user
shape. Unit tests cover cache behavior and claim validation. Integration
tests cover success and all failure paths including fail-closed behavior on
auth service unavailability. SDK has a README with usage examples.

---

### Step 11 — Docker and Kubernetes Manifests

**What to build:**

Implement `docker/Dockerfile` as a multi-stage build. Implement
`docker/docker-compose.yml` for local development and integration testing.
Implement all Kubernetes manifests in `k8s/`.

**Dockerfile rules:**

- Multi-stage build. Final image based on `python:3.11-slim`.
- App runs as a non-root user inside the container.
- Never bake secrets, `.env` files, or credentials into the image.

**Kubernetes manifests required:**

`Deployment` — minimum 3 replicas, rolling update strategy. Liveness probe
on `GET /health/live`. Readiness probe on `GET /health/ready`. Resource
requests and limits set on every container.

`HorizontalPodAutoscaler` — target 70% CPU utilization.

`PodDisruptionBudget` — `minAvailable: 2`.

`NetworkPolicy` — ingress from API gateway only, egress to Postgres, Redis,
and external IdPs only.

`Service` and `Ingress`.

Secrets managed via External Secrets Operator. Never commit raw secret
values to the repo.

**Done when:**

`docker compose up` starts the service with Postgres and Redis and the
service passes its readiness probe. All Kubernetes manifests are valid YAML.
No secrets or credentials appear anywhere in committed files.

---

### Step 12 — Integration Test Suite and Coverage Verification

**What to build:**

Complete the integration test suite in `tests/integration/` for all routers.
Verify coverage targets are met.

**Testing rules:**

- Use `httpx.AsyncClient` against a real test app instance.
- Use `testcontainers` for Postgres and Redis. Never mock the database in
  integration tests.
- Never mock cryptographic operations in integration tests. Use real test
  keys.
- All tests must be runnable with `pytest` from the repo root with no
  additional setup beyond `docker compose up`.

**Coverage targets:**

`app/core/` at 95%, `app/services/` at 90%, `app/routers/` at 85%.

**Security path coverage requirement:**

Every security-sensitive code path must have explicit tests for failure
cases, not just the happy path. This includes token validation, key
comparison, SAML assertion parsing, refresh token rotation, and all
fail-closed behaviors documented in steps 4 through 10.

**Done when:**

`pytest` passes from the repo root. Coverage targets are met or exceeded.
Every auth failure path documented in this specification has a corresponding
test that asserts the correct error code, HTTP status, and log output.

---

### Step 13 — Audit Service and Structured Auth Event Logging

**What to build:**

Implement `app/services/audit_service.py` to centralize structured auth
event emission. Wire it into all routers and services that perform auth
operations.

**Auth event log fields (required on every auth event):**

`event_type`, `user_id` (if known), `provider`, `ip_address`, `success`
(bool), `correlation_id`, `environment`, `service`, `level`, `timestamp`
(ISO 8601, UTC).

**Events that must be logged:**

Every token issuance, token refresh, login attempt, logout, and API key
usage.

**PII rules:**

Email addresses may be logged at INFO level. Names, phone numbers, and
addresses must not be logged. Tokens, passwords, and API keys must never
appear in any log entry. The logging middleware must redact credential
material before writing.

**Done when:**

Every auth operation emits a structured JSON log entry with all required
fields. No credential material appears in any log entry under any
circumstance. Redaction is verified by tests that assert log output does
not contain token or password strings.

---

### Step 14 — Load Testing and Security Review

**What to build:**

Write `locust` load test scenarios targeting the login and token refresh
endpoints. Perform a manual security review checklist pass over the full
codebase.

**Load test scenarios:**

Login under sustained concurrent load. Token refresh under sustained
concurrent load. Verify that rate limiting engages at the configured
thresholds and that Redis sliding window counters behave correctly under
concurrency.

**Security review checklist:**

Verify no plaintext passwords, tokens, or API keys exist anywhere in the
codebase or logs. Verify RS256 is the only JWT algorithm present. Verify all
cookie attributes (`Secure`, `HttpOnly`, `SameSite=Strict`) on every
Set-Cookie call. Verify all `redirect_uri` values are validated against the
allowlist before use. Verify `hmac.compare_digest()` is used for every token
and key comparison. Verify no `os.getenv()` calls exist outside
`app/config.py`. Verify no raw SQL strings exist anywhere. Verify no
`create_all()` call exists in any production code path. Verify the SDK
imports nothing from `app/`.

**Done when:**

Load tests pass with error rate below 0.1% at target concurrency. All
security checklist items are verified and documented. Any findings are
resolved before the service is considered production-ready.

---

## Authentication Flows Reference

### JWT Access Tokens

Algorithm: RS256 (asymmetric). Never HS256. Lifetime: 15 minutes. Claims:
`jti` (UUID), `iat`, `exp`, `sub` (user ID), `type: "access"`. Stateless
verification via public key. Public key distributed via
`GET /.well-known/jwks.json` (always public, unauthenticated). JWT blocklist
in Redis under `blocklist:jti:{jti}` for immediate revocation on security
events.

### Refresh Tokens and Session Persistence

The DB `sessions` table is the authoritative record. Redis is the cache.
They serve different purposes and must not be conflated. Session rebuild from
DB inline during auth is never permitted.

Redis stores session payload only, keyed by `session_id`: key
`session:{session_id}`, value `{ user_id, email, scopes, issued_at }`, TTL 7
days. The raw refresh token never touches Redis.

Refresh flow: hash incoming token, look up in DB, validate DB record, fetch
Redis payload via session_id, fail closed if Redis key missing, rotate token,
return new tokens.

Session records are created only for user-login flows. API key identity
flows are sessionless by design.

### Logout

Delete the Redis key and set `revoked_at` on the DB session in a single
transactional operation. Roll back the DB write if the Redis delete fails.
Add the access token `jti` to the Redis blocklist.

### OAuth2 / OIDC (Google)

Authorization Code flow with PKCE via `authlib`. State and nonce stored
server-side in Redis under `oauth_state:{state}`, TTL 10 minutes, one-time
use only. After token exchange: verify `id_token` against Google JWKS, check
`email_verified: true`, upsert `user_identities`, resolve or create canonical
`users` record, create session, issue tokens.

### SAML 2.0

Via `python3-saml`. Never parse SAMLResponse XML manually. Validate
signature, conditions, and audience restriction. SP metadata at
`GET /auth/saml/metadata`. After successful assertion, apply same identity
upsert flow as OAuth.

### API Keys

Format: `sk_{secrets.token_urlsafe(32)}`. Store `sha256(raw_key)` and first
8 characters as `key_prefix`. Raw key returned once at creation only. Must
have `scope`. Optional `expires_at`. Never creates a session record.
Verification via `POST /auth/introspect`.

---

## Middleware Stack Reference

Starlette applies middleware in reverse registration order. Register in
reverse to achieve the correct outermost-to-innermost execution order:

```python
app.add_middleware(TracingMiddleware)        # innermost, registered first
app.add_middleware(RateLimitMiddleware)
app.add_middleware(LoggingMiddleware)
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(MetricsMiddleware)
app.add_middleware(CorrelationIdMiddleware)  # outermost, registered last
```

Execution order rationale: Correlation ID must be outermost so every layer
below has a request-scoped ID. Metrics must be outside rate limiting to count
100% of traffic. Security headers must be outside rate limiting so rejected
responses carry correct headers. Logging wraps rate limiting so rejections are
captured. Rate limiting rejects bad traffic before expensive downstream work.
Tracing is innermost so spans measure handler time only.

---

## SDK Package Reference

Separate pip package named `auth-service-sdk`. Must not import from `app/`.
Runtime dependencies: `httpx`, `python-jose`, `cachetools`, `starlette` only.

Exposes: `JWTAuthMiddleware`, `APIKeyAuthMiddleware`, `AuthClient`.

`request.state.user` is type-discriminated by the `type` field. `type:
"user"` carries `{ type, user_id, email (required), scopes }`. `type:
"api_key"` carries `{ type, key_id, service, scopes, email: None }`.
Consuming services must check `type == "user"` before accessing `email`.

Introspection endpoint contract, JWKS cache behavior, and API key cache TTLs
are defined in full in step 10 above.

---

## Error Response Shape

All errors follow this exact shape:

```json
{ "detail": "<human readable message>", "code": "<machine readable code>" }
```

Valid error codes: `invalid_token`, `token_expired`, `invalid_api_key`,
`expired_api_key`, `revoked_api_key`, `invalid_credentials`, `rate_limited`,
`saml_assertion_invalid`, `oauth_state_mismatch`, `session_expired`.

---

## Security Requirements

- Plaintext passwords: never. Use `passlib` with `bcrypt`.
- Plaintext API keys: never. Store `sha256(key)` only.
- Plaintext refresh tokens: never. Store `sha256(token)` in DB only.
- Token and key comparisons: always `hmac.compare_digest()`, never `==`.
- JWT algorithm: RS256 only. Never HS256.
- Cookies: `Secure=True`, `HttpOnly=True`, `SameSite=Strict`.
- OAuth `redirect_uri`: validate against stored allowlist on every flow.
- SAML assertions: never trust without signature validation via `python3-saml`.
- Credential material: never log. Redact at logging middleware level.
- Secrets: environment variables or mounted Kubernetes Secrets only.

---

## Infrastructure Reference

### Docker

Multi-stage build. Final image: `python:3.11-slim`. Non-root user. No
secrets or `.env` files baked in.

### Kubernetes

`Deployment`: 3 replicas minimum, rolling update strategy. `HorizontalPodAutoscaler`:
target 70% CPU. `PodDisruptionBudget`: `minAvailable: 2`. `NetworkPolicy`:
ingress from API gateway only, egress to Postgres, Redis, and external IdPs
only. `Service` and `Ingress`. Liveness probe: `GET /health/live`. Readiness
probe: `GET /health/ready`. Resource requests and limits required on every
container. Secrets via External Secrets Operator. Never commit raw secret
values.

---

## Testing Strategy

Unit tests for all `app/core/` and `app/services/` modules. Coverage targets:
`app/core/` 95%, `app/services/` 90%, `app/routers/` 85%. Integration tests
with `httpx.AsyncClient` against a real test app instance, using
`testcontainers` for Postgres and Redis. Never mock the database or
cryptographic operations in integration tests. All tests runnable with
`pytest` from repo root after `docker compose up`. Load tests with `locust`
against login and token refresh before major releases.

---

## What Not to Build in v1

Do not implement any of the following unless explicitly instructed:

- MFA / TOTP / WebAuthn
- RBAC or scope enforcement beyond storing scopes in the JWT
- Admin API for user management
- Webhook system for auth events
- Consent management for OAuth
- Machine-to-machine Client Credentials flow
- Account lockout after failed attempts (rate limiting covers this in v1)
- Email verification or password reset flows
- Multi-tenancy activation (columns exist but logic is inactive)

---

## Design Principles

- Stateless where cryptographically possible (JWT); stateful only where
  necessary (sessions, OAuth state, rate limiting).
- Provider-agnostic identity model via `user_identities` table.
- Security first: fail closed on all infrastructure failures.
- Horizontal scalability: no in-process state that cannot be externalized.
- Observability built in from day one: structured logs, traces, metrics.