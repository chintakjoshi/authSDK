# Auth Service Architecture Specification

## Overview

Standalone authentication microservice responsible for identity, token
issuance, session management, and credential validation. Designed as an
internal authentication authority similar in role to Auth0 but
self-hosted and fully controllable.

---

## Repository Structure

```text
auth-service/
|-- app/
|   |-- main.py                  # App factory, middleware registration, router inclusion only
|   |-- config.py                # All settings via pydantic-settings
|   |-- dependencies.py          # Shared FastAPI dependencies
|   |-- middleware/
|   |   |-- correlation_id.py
|   |   |-- logging.py
|   |   |-- rate_limit.py
|   |   |-- security_headers.py
|   |   `-- tracing.py
|   |-- routers/
|   |   |-- auth.py              # Login, logout, refresh
|   |   |-- oauth.py             # OAuth2 / OIDC flows
|   |   |-- saml.py              # SAML flows
|   |   |-- apikeys.py           # API key management
|   |   `-- health.py
|   |-- core/
|   |   |-- jwt.py
|   |   |-- oauth.py
|   |   |-- saml.py
|   |   |-- api_keys.py
|   |   `-- sessions.py
|   |-- models/
|   |   |-- user.py
|   |   |-- session.py
|   |   `-- api_key.py
|   |-- schemas/
|   |   |-- token.py
|   |   |-- user.py
|   |   `-- api_key.py
|   |-- db/
|   |   |-- base.py
|   |   `-- session.py
|   `-- services/
|       |-- user_service.py
|       |-- token_service.py
|       `-- audit_service.py
|-- sdk/                         # Separate pip package: auth-service-sdk
|   |-- client.py
|   |-- middleware.py
|   `-- exceptions.py
|-- migrations/                  # Alembic
|-- tests/
|   |-- unit/
|   `-- integration/
|-- docker/
|   |-- Dockerfile
|   `-- docker-compose.yml
|-- k8s/
|   |-- deployment.yaml
|   |-- service.yaml
|   |-- ingress.yaml
|   |-- secrets.yaml
|   `-- hpa.yaml
`-- pyproject.toml
```

---

## Core Stack

- Python 3.11
- FastAPI + Uvicorn
- SQLAlchemy Async + asyncpg
- Postgres
- Redis (sessions, blocklist, OAuth state, rate limiting)
- Authlib (OAuth2 / OIDC client)
- python-jose (JWT)
- python3-saml (SAML 2.0)
- passlib + bcrypt (password hashing)
- OpenTelemetry
- Prometheus + prometheus-fastapi-instrumentator
- structlog

---

## Configuration Layer

All configuration lives in `app/config.py` via `pydantic-settings`. No
`os.getenv()` calls anywhere else. No hardcoded values. Settings instance
is cached via `@lru_cache`.

Key config groups: app identity, database URL, Redis URL, JWT keys (PEM,
injected as secrets), token TTLs, Google OAuth credentials, SAML SP/IdP
config, rate limit thresholds.

---

## Database Schema

All tables include: `id` (UUID), `created_at`, `updated_at`, `deleted_at`
(soft delete), `tenant_id` (nullable, reserved for v2 multi-tenancy).

Never hard-delete rows. Filter `deleted_at IS NULL` on all queries.
All migrations via Alembic. Never use `create_all()` in production.

### users

Canonical identity record. One row per human regardless of how they
authenticated.

### user_identities

Links a user to an external provider (google, saml, password). One user
can have multiple identities. Upsert here first on every OAuth or SAML
login, then resolve the canonical user record.

### sessions

Server-side session ledger for audit and forced revocation. Contains
`session_id`, `user_id`, `hashed_refresh_token`, `expires_at`,
`revoked_at`. This is the authoritative record. Redis is the cache.

### api_keys

Stores `sha256(raw_key)`, `key_prefix` (first 8 chars for UI display),
`scope`, `expires_at`, `revoked_at`. Raw key shown once on creation,
never stored.

---

## Authentication Flows

### JWT Access Tokens

- Algorithm: RS256 (asymmetric). Never HS256.
- Lifetime: 15 minutes.
- Claims: `jti` (UUID), `iat`, `exp`, `sub` (user ID), `type: "access"`.
- Stateless verification via public key.
- Public key distributed via `GET /.well-known/jwks.json` (always public,
  unauthenticated).
- JWT blocklist in Redis under `blocklist:jti:{jti}` for immediate
  revocation on security events.

### Refresh Tokens and Session Persistence

Refresh tokens and session data are intentionally split across DB and
Redis. They serve different purposes and must not be conflated.

**DB `sessions` table** is the authoritative record:
- `session_id` (UUID, stable across all rotations)
- `hashed_refresh_token` (sha256 of raw token, updated on every rotation)
- `expires_at`, `revoked_at`

**Redis** holds session payload only, keyed by session ID:
- Key: `session:{session_id}`
- Value: `{ user_id, email, scopes, issued_at }`
- TTL: 7 days

The raw refresh token never touches Redis. Redis holds no token material.

**Refresh flow:**
1. Hash the incoming token: `sha256(raw_token)`
2. Look up `hashed_refresh_token` in DB to find the session record
3. Validate `expires_at` and `revoked_at` on the DB record
4. Fetch session payload from Redis using `session_id`
5. If Redis key is missing, fail closed with `session_expired`
6. Rotate: new raw token, update `hashed_refresh_token` in DB, reset
   Redis TTL
7. Return new access token and new refresh token

Session records are only created for user-login flows (password, OAuth,
SAML). API key identity flows are sessionless by design.

### Logout

Delete the Redis key and set `revoked_at` on the DB session in a single
transactional operation. If Redis delete fails, roll back the DB write.
For immediate access token invalidation, add `jti` to the Redis blocklist.

### OAuth2 / OIDC (Google)

Authorization Code flow with PKCE via `authlib`.

OAuth `state` and `nonce` are stored server-side in Redis, not in
cookies. `SameSite=Strict` cookies are not sent on cross-site redirect
callbacks so cookie-based state is not present when the provider redirects
back to the callback URL.

State storage model:
- On login: generate `state` and `nonce`, store in Redis under
  `oauth_state:{state}`, TTL 10 minutes, redirect to Google.
- On callback: look up `oauth_state:{state}`, reject with
  `oauth_state_mismatch` if missing or expired, delete immediately
  (one-time use), proceed with token exchange.

After token exchange: verify `id_token` signature against Google JWKS,
check `email_verified: true`, upsert `user_identities`, resolve or create
canonical `users` record.

### SAML 2.0

Via `python3-saml`. Never parse SAMLResponse XML manually.

Flow: generate AuthnRequest, redirect to IdP, receive SAMLResponse at
callback, validate signature + conditions + audience restriction, upsert
identity using same flow as OAuth.

SP metadata at `GET /auth/saml/metadata` for IdP configuration.

### API Keys

Format: `sk_{secrets.token_urlsafe(32)}`

Storage: `sha256(raw_key)` in DB. `key_prefix` (first 8 chars) for
display. Raw key returned once on creation only.

Required fields: `scope` (never issue unscoped keys), optional
`expires_at`.

Verification uses `hmac.compare_digest()`. Never `==`.

---

## Middleware Stack

Starlette applies middleware in reverse registration order. Register in
reverse to achieve this outermost-to-innermost execution order:

```
1. Correlation ID         -- outermost. All layers below depend on it.
2. Prometheus metrics     -- outside rate limiting to count 100% of traffic.
3. Security headers       -- outside rate limiting so rejected responses
                            still carry correct headers.
4. Structured logging     -- wraps rate limiting to capture rejections.
5. Rate limiting          -- rejects bad traffic early, inside logging.
6. OpenTelemetry tracing  -- innermost, measures handler time only.
```

Registration order in code (reverse of above):
```python
app.add_middleware(TracingMiddleware)
app.add_middleware(RateLimitMiddleware)
app.add_middleware(LoggingMiddleware)
app.add_middleware(SecurityHeadersMiddleware)
app.add_middleware(MetricsMiddleware)
app.add_middleware(CorrelationIdMiddleware)
```

Rate limiting uses a Redis sliding window. Stricter limits apply to
`/auth/login` and `/auth/token`.

---

## SDK Package (auth-service-sdk)

The SDK is a separate pip package. It must not import from `app/`. It
communicates only via the service's public HTTP API.

Dependencies: `httpx`, `python-jose`, `cachetools`, `starlette`.

### JWTAuthMiddleware

Verifies Bearer tokens locally using cached public key. No network call
per request. Refreshes public key from JWKS endpoint at most once every 5
minutes and on verification failure.

### APIKeyAuthMiddleware

API keys are opaque strings with no cryptographic self-verification
property. Verification requires network introspection with a mandatory
in-process cache.

Flow:
1. Hash the raw key: `sha256(raw_key)`. Never hold the raw key longer.
2. Check `cachetools.TTLCache` keyed by hash. On hit, use cached result.
3. On miss: call `POST /auth/introspect` on the auth service.
4. Cache valid results for 60 seconds. Cache invalid results for 10
   seconds (prevents hammering on bad keys).
5. If auth service is unreachable, return 503 (not 401). Never fall back
   to a stale cache entry on error.

A revoked key remains valid on any instance that has it cached for up to
60 seconds. This is an accepted tradeoff. Immediate revocation requires
key deletion at the source, not cache invalidation.

### request.state.user shape

Type-discriminated by the `type` field:

```
type: "user"     -> { type, user_id, email (required), scopes }
type: "api_key"  -> { type, key_id, service, scopes, email: None }
```

Consuming services must check `type == "user"` before accessing `email`.

### Introspection endpoint contract (POST /auth/introspect)

Success: `{ "valid": true, "user_id": "...", "scopes": [...], "key_id": "...", "expires_at": "..." }`

Failure: `{ "valid": false, "code": "invalid_api_key" | "expired_api_key" | "revoked_api_key" }`

---

## SDK Kickoff Plan (Start Here)

Use this sequence to start building the SDK immediately, before the full
service is complete.

1. Freeze SDK-critical HTTP contracts:
   `GET /.well-known/jwks.json`, `POST /auth/introspect`, global error
   shape, and `request.state.user` variants.
2. Scaffold the package structure:
   `sdk/__init__.py`, `sdk/client.py`, `sdk/middleware.py`,
   `sdk/exceptions.py`, `sdk/types.py`, `sdk/cache.py`.
3. Implement shared SDK types and validation helpers for:
   Bearer token payload, introspection response, and injected user object.
4. Implement `AuthClient` with:
   async `httpx` client, sane timeouts, and methods for
   `fetch_jwks()` and `introspect_api_key()`.
5. Implement JWKS cache manager:
   in-process cache TTL 5 minutes, plus one forced refresh on JWT
   verification failure before final rejection.
6. Implement `JWTAuthMiddleware`:
   local JWT verification only, claim validation (`jti`, `exp`, `iat`,
   `sub`, `type`), and `request.state.user` injection.
7. Implement `APIKeyAuthMiddleware`:
   hash incoming key with `sha256`, check in-process cache, call
   `/auth/introspect` on miss, cache valid=60s and invalid=10s, return
   503 on auth-service unavailability, fail closed.
8. Add SDK tests:
   unit tests for cache behavior and claim validation, integration tests
   against a minimal Starlette/FastAPI app using both middlewares.
9. Add a consumer example app:
   one JWT-protected route and one API-key-protected route to show expected
   integration.
10. Publish-ready hardening:
    docstrings, README usage guide, typed public API, and packaging metadata
    for `auth-service-sdk`.

### SDK MVP Definition

The SDK MVP is complete when all of the following are true:
- `JWTAuthMiddleware` verifies tokens locally with JWKS cache refresh rules.
- `APIKeyAuthMiddleware` uses introspection plus mandatory short-lived
  in-process cache.
- `AuthClient` exposes at least JWKS fetch + API key introspection calls.
- Both middlewares inject the documented `request.state.user` shape.
- Tests cover success and failure paths, including fail-closed behavior.

---

## Error Response Shape

All errors follow this exact shape:

```json
{ "detail": "<human readable message>", "code": "<machine readable code>" }
```

Valid error codes: `invalid_token`, `token_expired`, `invalid_api_key`,
`expired_api_key`, `revoked_api_key`, `invalid_credentials`,
`rate_limited`, `saml_assertion_invalid`, `oauth_state_mismatch`,
`session_expired`.

---

## Security Requirements

- Plaintext passwords: never. Use `passlib` with `bcrypt`.
- Plaintext API keys: never. Store `sha256(key)` only.
- Plaintext refresh tokens: never. Store `sha256(token)` in DB only.
- Token and key comparisons: always `hmac.compare_digest()`, never `==`.
- JWT algorithm: RS256 only. Never HS256.
- Cookies: `Secure=True`, `HttpOnly=True`, `SameSite=Strict`.
- OAuth `redirect_uri`: validate against stored allowlist on every flow.
- SAML assertions: never trust without signature validation via
  `python3-saml`.
- Credential material: never log. Redact at logging middleware level.
- Secrets: environment variables or mounted Kubernetes Secrets only.
  Never in code, comments, or committed files.
- JWT signing key rotation: JWKS endpoint handles transparent rollover for
  consumers. Maintain an overlap period during rotation.

---

## Infrastructure

### Docker

Multi-stage build. Final image: `python:3.11-slim`. Non-root user. No
secrets or `.env` files baked in.

### Kubernetes

- `Deployment`: 3 replicas minimum, rolling update strategy
- `HorizontalPodAutoscaler`: target 70% CPU
- `PodDisruptionBudget`: `minAvailable: 2`
- `NetworkPolicy`: ingress from API gateway only, egress to Postgres,
  Redis, and external IdPs only
- `Service` + `Ingress`
- Liveness probe: `GET /health/live`
- Readiness probe: `GET /health/ready` (checks Postgres and Redis)
- Resource requests and limits required on every container
- Secrets via External Secrets Operator. Never commit raw secret values.

---

## Testing Strategy

### Unit Tests

Isolated module tests for all `app/core/` and `app/services/` modules.
Coverage targets: `app/core/` 95%, `app/services/` 90%, `app/routers/` 85%.

### Integration Tests

`httpx.AsyncClient` against a real test app instance. Real Postgres and
Redis via `testcontainers`. Never mock the database in integration tests.
Never mock cryptographic operations. Use real test keys.

### Contract Tests

JWKS endpoint, SAML metadata, and OAuth callback protocol correctness.

### Load Tests

`locust` against login and token refresh endpoints before major releases.

All tests runnable with `pytest` from repo root after `docker compose up`.

---

## Recommended Build Order

1. Config, DB models, Alembic migrations
2. User service + password login + JWT issuance
3. Redis sessions + refresh token rotation
4. Google OAuth flow
5. API key system
6. SAML
7. Middleware stack
8. SDK package hardening and release (initial SDK work starts earlier via
   the SDK Kickoff Plan)
9. Docker and Kubernetes manifests
10. Load testing and security review

---

## Design Principles

- Stateless where cryptographically possible (JWT); stateful only where
  necessary (sessions, OAuth state, rate limiting).
- Provider-agnostic identity model via `user_identities` table.
- Security first: fail closed on all infrastructure failures.
- Horizontal scalability: no in-process state that cannot be externalized.
- Observability built in from day one: structured logs, traces, metrics.
