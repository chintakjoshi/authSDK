# Auth Service v2 — Architecture Specification

## Overview

v2 extends the v1 auth service with account lifecycle management, RBAC,
machine-to-machine authentication, a webhook delivery system, a full admin
API, an immutable audit log, RS256 key rotation, and a two-mode email
verification system: link-based verification at signup and OTP-based
verification for login (as a second factor) and sensitive actions.

MFA methods beyond Email OTP (TOTP, WebAuthn, SMS) are deferred to v3.

Do not begin any step until v1 is complete, all its tests pass, and coverage
targets are met.

---

## Email Verification Design — Two Modes

Understand this before reading steps 4 and 5.

**Mode 1 — Signup link verification (step 4):**
Proves the user owns the email at registration. Passive: the user clicks a
link. No code entry. Fires once per account. If never clicked, the user can
still log in but their email_verified claim is false. Consuming services gate
features on this claim.

**Mode 2 — Login OTP and sensitive action OTP (step 5):**
Acts as a second factor during login and as a step-up gate for sensitive
actions. Active: the user receives a 6-digit code by email and types it in.
Any user with email_verified = true and email_otp_enabled = true participates.
The two sub-flows are:

Login OTP:
  Password valid + email_otp_enabled = true
  -> issue mfa_challenge_token (type: otp_challenge, no access rights)
  -> send 6-digit OTP to verified email via Mailhog
  -> return { otp_required: true, challenge_token, masked_email }
  -> client collects code, calls POST /auth/otp/verify/login
  -> on success: issue real access_token + refresh_token

Action OTP:
  User already authenticated with valid access token
  -> client calls POST /auth/otp/request/action { action: "role_change" }
  -> server sends OTP, returns { sent: true }
  -> client calls POST /auth/otp/verify/action { code, action }
  -> on success: server returns short-lived action_token
  -> client re-submits sensitive request with X-Action-Token header
  -> server validates action_token claim before executing

The mfa_challenge_token and action_token are different JWT types with
different scopes. Do not conflate them.

---

## Repository Structure Additions

auth-service/
|-- app/
|   |-- routers/
|   |   |-- lifecycle.py         # email verify, password reset, reauth
|   |   |-- otp.py               # email OTP request and verify endpoints
|   |   |-- admin.py
|   |   `-- webhooks.py
|   |-- core/
|   |   |-- signing_keys.py
|   |   `-- otp.py               # code generation, hashing, Redis storage
|   |-- models/
|   |   |-- oauth_client.py
|   |   |-- webhook_endpoint.py
|   |   |-- webhook_delivery.py
|   |   |-- audit_event.py
|   |   `-- signing_key.py
|   |-- schemas/
|   |   |-- lifecycle.py
|   |   |-- otp.py
|   |   |-- admin.py
|   |   |-- oauth_client.py
|   |   |-- webhook.py
|   |   `-- audit.py
|   `-- services/
|       |-- lifecycle_service.py
|       |-- otp_service.py
|       |-- admin_service.py
|       |-- webhook_service.py
|       |-- m2m_service.py
|       `-- audit_service.py     # expanded from v1 stub
|-- workers/
|   |-- __init__.py
|   `-- webhook_worker.py
|-- dev/
|   `-- .gitkeep
`-- worker.py

---

## New Dependencies

rq = "^1.16"
rq-scheduler = "^0.13"
fastapi-mail = "^1.4"

Add to docker-compose.yml:
- mailhog/mailhog on ports 1025 (SMTP) and 8025 (web UI)
- webhook-worker service running python worker.py, sharing the same image

---

## Implementation Steps

---

### Step 1 — Signing Key Versioning and JWKS Multi-Key Support

**What to build:**

Add a signing_keys table and implement app/core/signing_keys.py to support
multiple simultaneous RS256 key pairs. Update GET /.well-known/jwks.json to
serve all non-retired keys. Update JWT issuance to include the kid claim in
every token header.

**New table — signing_keys:**

id              UUID PK
kid             TEXT UNIQUE NOT NULL
public_key      TEXT NOT NULL               -- PEM
private_key     TEXT NOT NULL               -- PEM, encrypted at rest
status          ENUM ('active', 'retiring', 'retired')
activated_at    TIMESTAMP WITH TIME ZONE
retired_at      TIMESTAMP WITH TIME ZONE (nullable)
created_at, updated_at, deleted_at, tenant_id

Exactly one key may have status = 'active' at any time. Multiple keys may
have status = 'retiring'. Retired keys are excluded from all operations.

**Key rotation procedure:**

Step 1: Generate new RS256 key pair. Insert with status = 'active'.
        Update previous active key to status = 'retiring'.
        JWKS endpoint now serves both.

Step 2: Wait one full access token TTL. Configurable via
        ROTATION_OVERLAP_SECONDS for local dev.

Step 3: Update retiring key to status = 'retired'.
        JWKS endpoint now serves only the new key.

**JWKS endpoint update:**

GET /.well-known/jwks.json must serve all keys with status IN ('active',
'retiring'). Never serve 'retired' keys. Remains public and unauthenticated.

**JWT issuance update:**

Every token must include a kid claim in the JOSE header. Verification must
select the correct public key by kid. If no key matches, reject with
invalid_token.

**Constraints:**

- Never expose private key material via any endpoint or log.
- The v1 signing key from JWT_PRIVATE_KEY env var must be migrated into
  this table as the first 'active' key via a data migration. Env var path
  remains supported as local dev fallback.
- Add python -m app.cli rotate-signing-key as a CLI entrypoint.

**Done when:**

GET /.well-known/jwks.json returns a keys array. Tokens include kid. Rotating
via CLI results in two keys during the overlap window, then one after
retirement. Old-signed tokens verify during overlap and are rejected after
retirement. Unit tests cover multi-key verification, missing kid rejection,
and rotation state transitions.

---

### Step 2 — Expanded Audit Log

**What to build:**

Replace the v1 audit_service.py stub with a full implementation backed by a
new audit_events table. Wire into every auth operation across all existing
routers and services.

**New table — audit_events:**

id              UUID PK
event_type      TEXT NOT NULL
actor_id        UUID (nullable)
actor_type      ENUM ('user', 'service', 'admin', 'system')
target_id       UUID (nullable)
target_type     TEXT (nullable)
ip_address      INET
user_agent      TEXT
correlation_id  UUID
success         BOOLEAN NOT NULL
failure_reason  TEXT (nullable)
metadata        JSONB
created_at      TIMESTAMP WITH TIME ZONE NOT NULL

No updated_at. No deleted_at. No tenant_id. Append-only. No service method
may update or delete a row in audit_events under any circumstance.

**Event taxonomy — {entity}.{action}.{outcome} format:**

user.login.success              user.login.failure
user.login.otp_required         user.logout
user.created                    user.deleted
user.email.verified             user.password.changed
user.password.reset.requested   user.password.reset.completed
user.locked                     user.unlocked
user.reauth.success             user.reauth.failure
user.role_changed               user.erased
user.login.suspicious
otp.sent                        otp.verified
otp.failed                      otp.expired
otp.enabled                     otp.disabled
otp.admin_toggled               otp.excessive_failures
session.created                 session.revoked             session.expired
token.issued                    token.refreshed             token.revoked
api_key.created                 api_key.used                api_key.revoked
client.created                  client.authenticated
client.auth.failure             client.secret_rotated
webhook.delivered               webhook.failed

**audit_service.py contract:**

async def record(
    db: AsyncSession,
    event_type: str,
    actor_type: str,
    success: bool,
    request: Request,
    actor_id: str | None = None,
    target_id: str | None = None,
    target_type: str | None = None,
    failure_reason: str | None = None,
    metadata: dict | None = None,
) -> None

Audit writes are fire-and-forget. If a write fails, log at ERROR and
continue. A failed audit write must never roll back an auth operation or
surface an error to the client.

**PII rules:**

Metadata may contain user_id, key_id, session_id, and event-specific
non-PII fields. Email addresses must not appear in metadata. Tokens,
passwords, OTP codes, and API keys must never appear in any audit record.

**Done when:**

Every v1 auth operation emits a correctly shaped audit event. Audit write
failures do not affect auth outcomes. Unit tests assert failed writes are
logged and swallowed. Integration tests verify correct event_type and success
for both success and failure paths on each v1 auth operation.

---

### Step 3 — RBAC: Role Claim in JWT and SDK Enforcement

**What to build:**

Add a role column to the users table. Add role to JWT access token claims.
Update the SDK to include role in request.state.user. Add require_role() to
the SDK.

Three roles: admin, user, service. No others in v2.

**Schema change on users:**

role    TEXT NOT NULL DEFAULT 'user'
        CHECK (role IN ('admin', 'user', 'service'))

Human users never receive role = 'service'. M2M clients always receive
role = 'service'. Only admin can assign role = 'admin'.

**JWT claims update:**

{
  "sub": "<user_id>",
  "role": "user",
  "email": "user@example.com",
  "email_verified": false,
  "type": "access",
  "jti": "...",
  "iat": ...,
  "exp": ...,
  "kid": "..."
}

**SDK require_role() dependency:**

def require_role(*roles: str):
    def checker(user = Depends(get_current_user)):
        if user.get("role") not in roles:
            raise HTTPException(status_code=403, detail="Insufficient role")
        return user
    return checker

**Role assignment rules:**

- New users default to role = 'user'.
- Only admin can change any user's role.
- Demoting or deleting the last admin: 409, code last_admin_protected.
- Role changes emit a user.role_changed audit event before the DB write
  is committed.

**Done when:**

Access tokens include role. require_role() returns 403 for insufficient role.
Last admin cannot be demoted or deleted. Alembic migration adds the role
column. Unit and integration tests cover role enforcement and last-admin
protection.

---

### Step 4 — Account Lifecycle: Email Verification (Link-Based, Signup Only)

**What to build:**

Add email_verified and related columns to users. Issue a verification link on
signup. Implement the verification endpoint and resend endpoint. This step
covers signup verification only. OTP-based verification for login is step 5.

**Schema changes on users:**

email_verified              BOOLEAN NOT NULL DEFAULT false
email_verify_token_hash     TEXT (nullable)
email_verify_token_expires  TIMESTAMP WITH TIME ZONE (nullable)

**New config values:**

mailhog_host: str = "localhost"
mailhog_port: int = 1025
email_from: str = "auth@localhost"
email_verify_ttl_seconds: int = 86400    # 24 hours

**Verification link flow:**

On password signup: generate a signed JWT
{ sub: user_id, type: "email_verify", exp: now + 24h }, store sha256(token)
in email_verify_token_hash, set email_verify_token_expires, send email to
Mailhog with GET /auth/verify-email?token=<raw_token>.

GET /auth/verify-email?token=<token>:
1. Decode and verify JWT signature and type: "email_verify" claim.
2. Check exp. Expired or invalid: 400, code invalid_verify_token. Use the
   same code for both -- do not distinguish between expired and invalid.
3. Compute sha256(token). Query users where
   email_verify_token_hash = sha256(token).
4. If no match: 400, code invalid_verify_token.
5. Set email_verified = true. Null out both token columns.
   Emit user.email.verified audit event.

On OAuth and SAML signup: set email_verified from the provider's claim.
Never set email_verified = true without the provider asserting it.

**Resend endpoint:**

POST /auth/verify-email/resend requires a valid access token. Rate-limit to
3 requests per hour per user via Redis key email_verify_resend:{user_id} with
1-hour TTL. If already verified: 400, code already_verified. Otherwise
overwrite the token and resend.

**Relationship to step 5:**

email_otp_enabled can only be set to true if email_verified = true. This step
is the prerequisite gate for OTP. Build and test it fully before step 5.

**Constraints:**

- Verification tokens are single-use. Null out columns immediately on use.
- Same 400 code for expired and invalid tokens.
- Never set email_verified = true without a valid provider assertion or token.

**Done when:**

Signup sends a verification email to Mailhog. Clicking the link sets
email_verified = true and invalidates the token. Resend respects the rate
limit. OAuth signups with email_verified: true from Google produce a
verified user. Integration tests cover happy path, expired link, already-used
link, and resend rate limit.

---

### Step 5 — Email OTP: Login Second Factor and Sensitive Action Gate

**What to build:**

Implement Email OTP as a second factor for login and as a verification gate
for sensitive actions. Implement app/core/otp.py, app/services/otp_service.py,
and app/routers/otp.py. Update the login flow to issue an OTP challenge when
email_otp_enabled = true. Add require_action_token() to the SDK.

**Schema change on users:**

email_otp_enabled   BOOLEAN NOT NULL DEFAULT false

email_otp_enabled can only be set to true if email_verified = true.
Attempting to enable OTP for an unverified email returns 400 with code
email_not_verified.

**New config values:**

otp_code_length: int = 6
otp_ttl_seconds: int = 600             # 10 minutes
otp_max_attempts: int = 5
action_token_ttl_seconds: int = 300    # 5 minutes

**Redis keys for OTP:**

otp:login:{user_id}     HASH { code_hash, attempt_count, created_at }
                        TTL = otp_ttl_seconds

otp:action:{user_id}    HASH { code_hash, attempt_count, created_at, action }
                        TTL = otp_ttl_seconds

OTP codes are never stored in the database. Redis only. If Redis is
unavailable during any OTP operation, fail closed with 503.

**app/core/otp.py contract:**

def generate_otp(length: int = 6) -> str:
    # Zero-padded numeric string e.g. '048291'
    import secrets
    return str(secrets.randbelow(10 ** length)).zfill(length)

def hash_otp(code: str) -> str:
    import hashlib
    return hashlib.sha256(code.encode()).hexdigest()

def verify_otp(raw_code: str, stored_hash: str) -> bool:
    import hmac
    return hmac.compare_digest(hash_otp(raw_code), stored_hash)

Never log the raw OTP code. Never store it anywhere except the Redis hash.
Never include it in structured logs even in development mode.

**masked_email helper:**

def mask_email(email: str) -> str:
    local, domain = email.split("@", 1)
    return f"{local[0]}{'*' * (len(local) - 1)}@{domain}"

---

#### Part A — Login OTP Flow

**Updated POST /auth/login:**

If user.email_otp_enabled = false:
    Issue access_token + refresh_token as before. Identical to v1.

If user.email_otp_enabled = true:
    1. Generate OTP via generate_otp().
    2. Store hash in Redis: otp:login:{user_id}, TTL otp_ttl_seconds.
       Overwrite any existing key.
    3. Send OTP email to Mailhog.
       Subject: "Your login verification code"
       Body: "Your verification code is: {code}. It expires in 10 minutes."
    4. Issue mfa_challenge_token:
           jwt.encode({
               sub: user_id,
               type: "otp_challenge",
               exp: now + otp_ttl_seconds,
               kid: <active_kid>
           })
    5. Return:
           {
               "otp_required": true,
               "challenge_token": "<mfa_challenge_token>",
               "masked_email": "j***@example.com"
           }
       Do NOT return access_token or refresh_token at this stage.

The mfa_challenge_token is a short-lived JWT that grants zero access to
protected resources. JWTAuthMiddleware in the SDK must reject tokens with
type: "otp_challenge" on all protected routes.

**POST /auth/otp/verify/login:**

Body: { challenge_token, code }

1. Verify challenge_token signature, exp, and type: "otp_challenge".
   If invalid or expired: 401, code invalid_token.

2. Extract user_id from challenge_token.sub.

3. Fetch otp:login:{user_id} from Redis.
   If missing: 401, code otp_expired.

4. Atomically increment attempt_count.
   If attempt_count > otp_max_attempts:
       Delete Redis key.
       Emit otp.expired audit event.
       Return 401, code otp_max_attempts_exceeded.

5. verify_otp(raw_code, stored_hash).
   If invalid:
       Emit otp.failed audit event.
       Return 401, code invalid_otp.
       Do not delete the Redis key -- allow remaining attempts.

6. On success:
       Delete otp:login:{user_id} from Redis immediately (replay protection).
       Emit otp.verified audit event.
       Create session and issue access_token + refresh_token using the same
       flow as password login.

**POST /auth/otp/resend/login:**

Body: { challenge_token }

Validate challenge_token. Rate-limit to 3 resends per challenge window via
Redis key otp_resend_login:{user_id} with TTL otp_ttl_seconds.
Generate a new code, overwrite otp:login:{user_id}, send new email.
Return { "sent": true }.

---

#### Part B — Sensitive Action OTP Flow

For sensitive actions the user is already authenticated with a valid access
token. The OTP is a step-up verification gate, not a second login factor.

**Operations that require an action token:**

- PATCH /admin/users/{user_id}         action: "role_change"
- DELETE /admin/users/{user_id}        action: "delete_user"
- DELETE /admin/users/{user_id}/sessions  action: "revoke_sessions"
- POST /admin/signing-keys/rotate      action: "rotate_signing_key"
- POST /auth/users/me/erase            action: "erase_account"
- POST /auth/otp/enable                action: "enable_otp"
- POST /auth/otp/disable               action: "disable_otp"

**POST /auth/otp/request/action:**

Requires: valid access token.
Body: { action }

1. Confirm user.email_verified = true.
   If not: 400, code email_not_verified.

2. Check otp_issuance_blocked:{user_id} in Redis.
   If set: 429, code otp_issuance_blocked, Retry-After header.

3. Generate OTP. Store in Redis:
   otp:action:{user_id} = { code_hash, attempt_count: 0, action }
   TTL = otp_ttl_seconds.
   Overwrite any existing key (one active action OTP per user at a time).

4. Send OTP email to Mailhog.
   Subject: "Verification code for {action}"
   Body: "Your verification code is: {code}. It expires in 10 minutes."

5. Emit otp.sent audit event.

6. Return { "sent": true, "action": action, "expires_in": otp_ttl_seconds }.

**POST /auth/otp/verify/action:**

Requires: valid access token.
Body: { code, action }

1. Fetch otp:action:{user_id} from Redis.
   If missing: 401, code otp_expired.

2. Confirm stored action matches submitted action.
   If mismatch: 401, code otp_action_mismatch.

3. Atomically increment attempt_count.
   If > otp_max_attempts:
       Delete Redis key.
       Emit otp.expired audit event.
       Return 401, code otp_max_attempts_exceeded.

4. verify_otp(raw_code, stored_hash).
   If invalid:
       Increment otp_failed:{user_id} in Redis (TTL 1 hour).
       If otp_failed:{user_id} > 10:
           Set otp_issuance_blocked:{user_id} with TTL 900 seconds.
           Emit otp.excessive_failures audit event.
       Emit otp.failed audit event.
       Return 401, code invalid_otp.

5. On success:
       Delete otp:action:{user_id} from Redis immediately.
       Issue action_token:
           jwt.encode({
               sub: user_id,
               type: "action_token",
               action: action,
               exp: now + action_token_ttl_seconds,
               kid: <active_kid>
           })
       Emit otp.verified audit event.
       Return { "action_token": "<token>" }.

**How sensitive endpoints consume the action token:**

Sensitive endpoints expect X-Action-Token in the request header. Validation
is done inside the relevant service method (not middleware):

1. Verify JWT signature, exp, and type: "action_token".
2. Confirm action claim matches the operation being performed.
3. Confirm sub matches the authenticated user's user_id.

If any check fails: 403, code action_token_invalid.

**SDK require_action_token() dependency:**

def require_action_token(action: str):
    def checker(request: Request, user = Depends(get_current_user)):
        token = request.headers.get("X-Action-Token")
        if not token:
            raise HTTPException(
                status_code=403,
                detail="Action token required",
                headers={"X-OTP-Required": "true", "X-OTP-Action": action}
            )
        claims = verify_action_token(token)
        if claims.get("action") != action:
            raise HTTPException(status_code=403, detail="Action mismatch")
        if claims.get("sub") != user.get("user_id"):
            raise HTTPException(status_code=403, detail="Token user mismatch")
        return user
    return checker

When X-Action-Token is absent, the 403 includes X-OTP-Required: true and
X-OTP-Action: <action> so the client knows which action OTP to request.

---

#### Part C — OTP Enrollment and Management

**POST /auth/otp/enable:**

Requires: valid access token + require_action_token("enable_otp").
1. Confirm email_verified = true. If not: 400, code email_not_verified.
2. Set email_otp_enabled = true.
3. Emit otp.enabled audit event.
Return { "email_otp_enabled": true }.

**POST /auth/otp/disable:**

Requires: valid access token + require_action_token("disable_otp").
1. Set email_otp_enabled = false.
2. Delete otp:login:{user_id} and otp:action:{user_id} from Redis if present.
3. Emit otp.disabled audit event.
Return { "email_otp_enabled": false }.

Both require completing the action OTP flow first -- the user must receive a
code, verify it, and use the resulting action_token to call enable/disable.

**OTP failure tracking across multiple challenges:**

Track cumulative OTP failures in Redis key otp_failed:{user_id} (INTEGER,
TTL 1 hour). Increment on every otp.failed event. If value exceeds 10 within
1 hour, set otp_issuance_blocked:{user_id} with TTL 900 seconds. Emit
otp.excessive_failures audit event.

POST /auth/otp/request/action and the OTP branch in POST /auth/login must
both check otp_issuance_blocked:{user_id} before issuing a new code.
If blocked: 429, code otp_issuance_blocked, Retry-After header.

**Constraints:**

- OTP codes are never stored in the database. Redis only.
- OTP codes must never appear in logs, audit records, or API responses.
- otp_challenge and action_token JWT types must be rejected by
  JWTAuthMiddleware for all normal protected routes.
- Action tokens expire in 5 minutes via exp. Document this tradeoff.
- If Redis is unavailable, fail closed on all OTP operations. Return 503.
- Users with email_otp_enabled = false are completely unaffected by all
  OTP code paths. Their login flow is identical to v1.

**New error codes:**

otp_expired, invalid_otp, otp_max_attempts_exceeded, otp_action_mismatch,
action_token_invalid, otp_required, email_not_verified, otp_issuance_blocked

**Done when:**

Login with email_otp_enabled = true returns otp_required: true and a
challenge_token. POST /auth/otp/verify/login with correct code issues real
tokens. Wrong code returns 401 without invalidating the challenge. After
otp_max_attempts wrong attempts the challenge is invalidated. Resend replaces
the active code and respects rate limiting. Sensitive action endpoints return
403 with X-OTP-Required: true when no X-Action-Token is present. An
action_token for the wrong action is rejected. Cumulative OTP failure tracking
blocks issuance after 10 failures. Users with email_otp_enabled = false pass
through login without any OTP step. Unit tests cover code generation, hashing,
attempt counting, expiry, and failure tracking. Integration tests cover the
full login OTP flow, the full action OTP flow, max-attempts lockout, resend,
failure tracking, issuance block, and all rejection paths.

---

### Step 6 — Account Lifecycle: Password Reset

**What to build:**

Implement forgot password and reset password flows. Wire session revocation
into password reset completion.

**Schema changes on users:**

password_reset_token_hash       TEXT (nullable)
password_reset_token_expires    TIMESTAMP WITH TIME ZONE (nullable)

**Forgot password flow:**

POST /auth/password/forgot accepts { email }. Always returns 200 regardless
of whether the email exists. This prevents user enumeration. If user exists:
generate secrets.token_urlsafe(32), store sha256(token) and expiry
(now + 1 hour), send email to Mailhog with reset link. If user does not
exist: perform a constant-time dummy hash operation and return 200.

Only one active reset token per user. Issuing a new one overwrites the
previous.

**Validation endpoint:**

GET /auth/password/reset?token=<token> returns { "valid": true } if valid
and unexpired. Otherwise 400 with code invalid_reset_token. Do not
distinguish expired from invalid.

**Reset completion flow:**

POST /auth/password/reset accepts { token, new_password }. Hash incoming
token, look up matching record, validate expiry. Update password hash. Null
out both reset token columns. Revoke all active sessions synchronously within
the same transaction as the password update: set revoked_at on all DB session
records, delete all corresponding Redis keys. If Redis is unavailable, fail
closed: do not complete the reset, return 503. Send confirmation email.
Emit user.password.reset.completed audit event.

**Constraints:**

- Reset tokens are single-use. Null out both columns immediately on use.
- All sessions must be revoked synchronously in the same transaction.
- If the user has email_otp_enabled = true, do not disable OTP on password
  reset. OTP is tied to the email address, not the password.
- Never log the reset token in any form.

**Done when:**

Forgot password sends an email to Mailhog. Reset sets the new password and
revokes all sessions. Timing consistency on non-existent email verified by
test. Integration tests cover happy path, expired token, already-used token,
and session revocation on reset.

---

### Step 7 — Account Lifecycle: Brute Force Protection and Lockout

**What to build:**

Implement per-account failed attempt tracking and lockout in Redis.
Implement distributed attack detection. Wire into the login endpoint and
OTP verification endpoints.

**Redis keys:**

failed_attempts:{user_id}       INTEGER, TTL resets on each increment
lockout:{user_id}               SET when locked, TTL = lockout duration
distributed_attack:{user_id}    HyperLogLog, TTL 5 minutes
otp_failed:{user_id}            INTEGER, TTL 1 hour (managed in step 5)
otp_issuance_blocked:{user_id}  SET when OTP issuance blocked, TTL 900s

**Per-account lockout policy (password login failures):**

Attempts 1-4:   Increment counter only.
Attempt 5:      Lock for 60 seconds.
Attempt 6:      Lock for 300 seconds.
Attempt 7:      Lock for 900 seconds.
Attempt 8+:     Lock for 3600 seconds.

On any successful login: delete failed_attempts:{user_id} and
lockout:{user_id}.

When locked: 401 with Retry-After header and code account_locked.

**Distributed attack detection:**

On each failed password login: PFADD distributed_attack:{user_id} {ip}.
TTL 5 minutes. If estimated distinct IP count exceeds 10 within the window:
immediately apply 3600-second lockout. Emit user.locked audit event and
user.locked webhook event.

**Suspicious login flagging (non-blocking):**

After successful login: check for new IP not in seen_ips:{user_id} set, or
new user-agent not in seen_agents:{user_id} set, or login after 3+ prior
failures. If any are true: emit user.login.suspicious audit event. Do not
block.

Refresh both Redis sets TTL to 30 days on each successful login.

**Constraints:**

- Brute force protection applies to password login and OTP verification.
  OAuth, SAML, and API key paths are not subject to per-account lockout.
- Operates independently of and in addition to the v1 IP-based rate limiting.
- Never expose which condition triggered the lockout. Always account_locked.

**Done when:**

Five consecutive password login failures trigger a lockout with correct TTL.
Distributed detection triggers at 10 distinct IPs. Successful login clears
the counter. Retry-After header is correct. Unit tests cover each lockout
threshold and distribution detection threshold. Integration tests verify
header and error code.

---

### Step 8 — Account Lifecycle: Re-authentication

**What to build:**

Implement POST /auth/reauth and add auth_time to JWT claims. Add
require_fresh_auth() to the SDK. Define the dual-gate pattern for sensitive
endpoints.

**Dual-gate pattern for sensitive endpoints:**

Sensitive endpoint receives request:

1. Check for X-Action-Token header.
   If present and valid (require_action_token(action)):
       Allow through regardless of email_otp_enabled.

2. If X-Action-Token absent or invalid:
   If user.email_otp_enabled = true:
       Reject with 403, code otp_required.
       Include X-OTP-Required: true, X-OTP-Action: <action>.
       OTP-enabled users must use the OTP gate, not password reauth.
   If user.email_otp_enabled = false:
       Check require_fresh_auth(300).
       If auth_time within 300 seconds: allow through.
       If auth_time stale: return 403, code reauth_required,
       X-Reauth-Required: true.

Users with OTP enabled are gated exclusively by OTP. Users without OTP are
gated by password re-entry. The gates do not overlap.

**JWT changes:**

Add auth_time (Unix timestamp, set at login time, carried through refresh
unchanged) to every access token.

**Schema change on sessions:**

auth_time   TIMESTAMP WITH TIME ZONE NOT NULL

Set at session creation. Carried forward unchanged through all token
rotations.

**Re-authentication endpoint:**

POST /auth/reauth requires a valid access token. Accepts { password }.
Validates the password. On success: updates auth_time on the session record
and Redis payload to now, issues a new access token with fresh auth_time.
Does not rotate the refresh token. Emits user.reauth.success or
user.reauth.failure audit event. Applies brute force increment on failure.

**SDK require_fresh_auth() dependency:**

def require_fresh_auth(max_age_seconds: int = 300):
    def checker(user = Depends(get_current_user)):
        auth_time = user.get("auth_time", 0)
        if time.time() - auth_time > max_age_seconds:
            raise HTTPException(
                status_code=403,
                detail="Re-authentication required",
                headers={"X-Reauth-Required": "true"}
            )
        return user
    return checker

**Done when:**

auth_time appears in all new access tokens. POST /auth/reauth issues a new
token with fresh auth_time. OTP-enabled users are directed to the OTP gate
on sensitive endpoints. Non-OTP users are directed to password reauth.
Integration tests cover both paths, both 403 responses, and auth_time
propagation through refresh.

---

### Step 9 — M2M Client Credentials Flow

**What to build:**

Implement the OAuth2 Client Credentials grant. Implement
app/services/m2m_service.py and app/models/oauth_client.py. Add the
grant_type=client_credentials branch to POST /auth/token.

**New table — oauth_clients:**

id                      UUID PK
client_id               TEXT UNIQUE NOT NULL
client_secret_hash      TEXT NOT NULL
client_secret_prefix    TEXT NOT NULL           -- first 8 chars
name                    TEXT NOT NULL
scopes                  TEXT[] NOT NULL
role                    TEXT NOT NULL DEFAULT 'service'
is_active               BOOLEAN NOT NULL DEFAULT true
token_ttl_seconds       INTEGER NOT NULL DEFAULT 3600
created_at, updated_at, deleted_at, tenant_id

**Token endpoint:**

POST /auth/token with application/x-www-form-urlencoded:

grant_type=client_credentials
client_id=<client_id>
client_secret=<raw_secret>
scope=<optional, must be subset of client scopes>

Validate client_secret with
hmac.compare_digest(sha256(raw), stored_hash).

**JWT claims for M2M tokens:**

{
  "sub": "<client_id>",
  "type": "m2m",
  "role": "service",
  "scope": "billing:read",
  "jti": "...",
  "iat": ...,
  "exp": ...,
  "kid": "..."
}

No refresh token. No session record. No auth_time claim. OTP flows never
apply to M2M clients.

Response shape (OAuth2 spec):

{
  "access_token": "...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "scope": "billing:read"
}

Client secret format: cs_{secrets.token_urlsafe(32)}

**Constraints:**

- M2M tokens never create session records.
- Inactive clients: 401.
- Scope outside allowed set: 400, code invalid_scope.
- Emit client.authenticated audit event on success.
  client.auth.failure on failure.

**Done when:**

POST /auth/token returns a verifiable M2M JWT. Invalid secret, inactive
client, and bad scope return correct codes. No session record is created.
SDK JWTAuthMiddleware verifies M2M tokens. Unit and integration tests cover
all failure paths.

---

### Step 10 — Webhook System

**What to build:**

Implement webhook endpoint registration, delivery record tracking, and the
RQ worker. Implement app/services/webhook_service.py. Wire event emission
into all auth operations.

**New table — webhook_endpoints:**

id          UUID PK
name        TEXT NOT NULL
url         TEXT NOT NULL
secret      TEXT NOT NULL               -- stored encrypted, used for HMAC signing
events      TEXT[] NOT NULL DEFAULT '{}'
is_active   BOOLEAN NOT NULL DEFAULT true
created_at, updated_at, deleted_at, tenant_id

**New table — webhook_deliveries:**

id                  UUID PK
endpoint_id         UUID FK -> webhook_endpoints.id
event_type          TEXT NOT NULL
payload             JSONB NOT NULL
status              TEXT NOT NULL CHECK (status IN ('pending','delivered','failed','abandoned'))
attempt_count       INTEGER NOT NULL DEFAULT 0
last_attempted_at   TIMESTAMP WITH TIME ZONE (nullable)
next_retry_at       TIMESTAMP WITH TIME ZONE (nullable)
response_status     INTEGER (nullable)
response_body       TEXT (nullable)     -- truncated to 1000 characters
created_at

No updated_at, deleted_at, or tenant_id on webhook_deliveries. It is an
event ledger.

**Payload format:**

{
  "id": "<delivery-uuid>",
  "event": "user.created",
  "created_at": "2024-01-01T00:00:00Z",
  "data": { ... }
}

**Signature:**

def sign_payload(payload: dict, secret: str) -> str:
    body = json.dumps(payload, separators=(",", ":"), sort_keys=True)
    digest = hmac.new(secret.encode(), body.encode(), hashlib.sha256).hexdigest()
    return f"sha256={digest}"

**emit_event() rules:**

Call after committing the DB transaction. Never inside the transaction. If
it raises, log at ERROR and swallow.

**RQ worker retry schedule:**

Attempt 1 failure: retry after 60 seconds
Attempt 2 failure: retry after 300 seconds
Attempt 3 failure: retry after 1800 seconds
Attempt 4 failure: retry after 7200 seconds
Attempt 5 failure: abandon, emit webhook.failed audit event

**Events to emit (wire into existing services):**

user.created, user.deleted, user.email.verified, user.password.changed,
user.locked, user.unlocked, session.created, session.revoked,
otp.verified (both login and action OTP), api_key.created, api_key.revoked,
client.created, client.secret_rotated

**Constraints:**

- Reject webhook URLs pointing to localhost or private IP ranges at
  registration time with code invalid_webhook_url. Prevents SSRF. Checked
  ranges: 127.0.0.1, ::1, localhost, 10.x.x.x, 172.16-31.x.x, 192.168.x.x.
- Delivery attempts must be idempotent. Already-delivered deliveries are
  no-ops on reprocessing.
- Never call emit_event() inside a DB transaction.

**Done when:**

Registering a webhook and triggering a login results in a session.created
delivery. Failed deliveries retry with correct backoff and are abandoned
after 5 attempts. HMAC signature is verifiable. SSRF-blocked URLs rejected
at registration. Integration tests verify end-to-end delivery, retry
backoff, abandonment, and idempotent re-delivery.

---

### Step 11 — Admin API

**What to build:**

Implement app/routers/admin.py and app/services/admin_service.py. All admin
endpoints require role = 'admin' via require_role("admin"). Sensitive
operations additionally require the dual-gate from step 8.

**Pagination:**

Cursor-based on all list endpoints. Never OFFSET. Response shape:

{
  "data": [...],
  "next_cursor": "<base64-cursor or null>",
  "has_more": false
}

Accept ?cursor=<value>&limit=<n>. Default limit = 50. Max limit = 200.

**User management endpoints:**

GET    /admin/users
       Params: role, email (partial match), locked (bool), cursor, limit.
       Never include password hash in response.

GET    /admin/users/{user_id}
       User detail including active session count, email_verified,
       email_otp_enabled.

PATCH  /admin/users/{user_id}
       Allowed: role.
       Gate: require_action_token("role_change") or reauth fallback.
       Demoting last admin: 409, code last_admin_protected.

DELETE /admin/users/{user_id}
       Soft-delete. Revoke all active sessions synchronously.
       Gate: require_action_token("delete_user") or reauth fallback.
       Blocks last admin deletion.

DELETE /admin/users/{user_id}/sessions
       Revoke all sessions. Delete Redis keys.
       Gate: require_action_token("revoke_sessions") or reauth fallback.

PATCH  /admin/users/{user_id}/otp
       Allowed: email_otp_enabled (bool).
       Admin can disable OTP for a user (e.g. locked-out user who lost
       email access). Cannot enable OTP for unverified email.
       No action token required -- admin role is sufficient.
       Emits otp.admin_toggled audit event.

**API key management:**

GET    /admin/api-keys       Params: scope, active (bool), cursor, limit.
POST   /admin/api-keys       { name, scope, expires_at? } Returns raw key once.
DELETE /admin/api-keys/{id}  Sets revoked_at.

**M2M client management:**

GET    /admin/clients
POST   /admin/clients                     { name, scopes, token_ttl_seconds? }
PATCH  /admin/clients/{id}                name, scopes, token_ttl_seconds, is_active
POST   /admin/clients/{id}/rotate-secret  Returns raw secret once. Old secret
                                          invalid immediately.
DELETE /admin/clients/{id}

**Webhook management:**

GET    /admin/webhooks
POST   /admin/webhooks                    { name, url, secret, events? }
PATCH  /admin/webhooks/{id}               name, url, events, is_active
DELETE /admin/webhooks/{id}               soft-delete, abandon pending deliveries
GET    /admin/webhooks/{id}/deliveries    Params: status, cursor, limit.
POST   /admin/webhooks/deliveries/{id}/retry  Resets attempt_count to 0.

**Audit log:**

GET    /admin/audit-log
       Params: actor_id, event_type (prefix match), success (bool),
               date_from, date_to, cursor, limit.
       Read-only. No mutation ever.

**Signing key management:**

POST   /admin/signing-keys/rotate
       Gate: require_action_token("rotate_signing_key") or reauth fallback.
       Returns { new_kid, retiring_kid }.

**Constraints:**

- Never include password hashes, raw secrets, OTP codes, or tokens in any
  admin response.
- All mutating operations emit an audit event before returning.
- ADMIN_API_KEY env var bootstrap is for local dev only.

**Done when:**

All endpoints return correct data. Cursor pagination works across pages.
Non-admin JWTs return 403 on all /admin/* routes. Last admin is protected.
Dual-gate enforcement works on sensitive endpoints. Admin OTP toggle works.
Unit and integration tests cover all CRUD paths and pagination.

---

### Step 12 — GDPR Erasure and Data Retention Scaffolding

**What to build:**

Implement user self-service and admin erasure endpoints. Add data retention
configuration and a callable but unscheduled retention purge function.

**Erasure flow:**

POST /auth/users/me/erase requires valid access token and
require_action_token("erase_account"):

1. Overwrite PII on users:
   email -> deleted_{user_id}@erased.invalid. Null all PII columns.
2. Set email_otp_enabled = false.
3. Delete otp:login:{user_id}, otp:action:{user_id},
   otp_failed:{user_id}, otp_issuance_blocked:{user_id} from Redis.
4. Null out all token columns (email_verify_token_hash etc.).
5. Hard-delete all user_identities rows.
6. Revoke all active sessions: delete Redis keys, set revoked_at.
7. Revoke all API keys: set revoked_at.
8. Set deleted_at on the users row.
9. Emit user.erased audit event (anonymized user_id only, no PII).
10. Emit user.erased webhook event.

DELETE /admin/users/{user_id}/erase performs the same steps on behalf of an
admin. Requires require_role("admin") and
require_action_token("admin_erase_user").

Idempotency: if email already matches deleted_*@erased.invalid, return 409
with code already_erased.

**Data retention config:**

enable_retention_purge: bool = False
audit_log_retention_days: int = 90
session_log_retention_days: int = 30

run_retention_purge() in admin_service.py is callable but not wired to any
endpoint or scheduler in v2. No-ops when enable_retention_purge = False.

**Constraints:**

- user_identities rows are the only records hard-deleted during erasure.
- All OTP Redis keys for the erased user must be cleaned up.
- Audit log must contain no PII after erasure. Verified in tests.

**Done when:**

Erasure anonymizes the user, disables OTP, cleans all OTP Redis keys, revokes
all sessions and keys, emits audit and webhook events. Post-erasure sessions
and OTP codes are rejected. Audit records contain no PII. Erasure is
idempotent. run_retention_purge() no-ops when disabled.

---

### Step 13 — Integration Test Suite and Coverage Verification

**What to build:**

Complete the integration test suite for all v2 routers and services. Verify
coverage targets.

**Testing rules:**

- httpx.AsyncClient against a real test app instance.
- testcontainers for Postgres and Redis.
- Never mock the database or cryptographic operations in integration tests.
- All tests runnable with pytest from repo root after docker compose up.

**Coverage targets:**

app/core/ at 95%, app/services/ at 90%, app/routers/ at 85%.

**Required test cases by feature:**

JWKS rotation: both keys during overlap, old-signed valid during overlap,
rejected after retirement.

Email verification link: happy path, expired link, already-used link, resend
rate limit, OAuth verified user.

Login OTP: full flow happy path, wrong code, max-attempts lockout, challenge
token rejected on protected routes, resend replaces active code, users
without OTP completely unaffected.

Action OTP: request + verify + use action token happy path, wrong action
claim rejected, expired action token rejected, OTP failure tracking across
multiple challenges, issuance block at 10 failures.

OTP enrollment: enable blocked if email unverified, disable clears login
OTP gate and deletes Redis OTP keys.

Password reset: happy path, expired token, already-used token, session
revocation, Redis-down fail-closed.

Brute force: each lockout threshold, distributed IP detection, counter reset
on success, OTP issuance block.

Re-authentication: auth_time through refresh, OTP-enabled users use OTP
gate, non-OTP users use password reauth gate, both 403 paths.

M2M: happy path, invalid secret, inactive client, scope validation, SDK
verification.

Webhook: end-to-end delivery, HMAC verification, retry backoff, abandonment,
idempotent re-delivery, SSRF rejection.

Admin API: role gate, last-admin protection, cursor pagination, dual-gate
enforcement, admin OTP toggle.

GDPR erasure: full flow, post-erasure session rejection, OTP Redis keys
cleaned, PII absence in audit records, idempotency.

**Security path coverage:**

Every fail-closed behavior documented in steps 1 through 12 must have an
explicit test asserting the correct error code, HTTP status, and log output.

**Done when:**

pytest passes from repo root. Coverage targets met. Every auth failure path
documented in this specification has a corresponding test.

---

### Step 14 — Load Testing and Security Review

**What to build:**

Extend v1 locust scenarios. Add new scenarios. Perform a full security review
checklist for all v2 additions.

**New locust scenarios:**

OTP login flow under concurrent load. Verify per-user challenge token
isolation: user A's challenge cannot satisfy user B's OTP.

Sensitive action OTP flow under load: request + verify + submit action.

M2M token issuance under sustained concurrent load. Verify no session records
are created.

Admin list endpoints under concurrent read load. Verify cursor pagination
produces no duplicates or missing records.

Webhook delivery queue depth under high event volume.

**Security review checklist (v2 additions):**

Verify OTP codes never appear in any log entry, API response, or audit
record. Verify otp_challenge and action_token types are rejected by
JWTAuthMiddleware on protected routes. Verify action tokens carry a specific
action claim and are rejected on claim mismatch. Verify email_otp_enabled
cannot be set to true without email_verified = true. Verify OTP challenge
isolation: user A's challenge token cannot be used to satisfy user B's OTP
verification. Verify OTP Redis keys are deleted immediately on successful
verification (replay protection). Verify OTP failure tracking blocks issuance
correctly. Verify SSRF protection covers all private IP variants. Verify audit
log has no UPDATE or DELETE via any code path. Verify erasure cleans all OTP
Redis keys. Verify last admin protection cannot be bypassed via concurrent
requests (use a serializable transaction or DB-level constraint).

**Done when:**

Load tests pass with error rate below 0.1% at target concurrency. All
security checklist items verified and documented. Any findings resolved before
v2 is considered complete.

---

## Error Response Shape (v2 Full List)

All v1 error codes remain valid. v2 additions:

account_locked, last_admin_protected, already_verified, invalid_verify_token,
invalid_reset_token, reauth_required, invalid_scope, already_erased,
invalid_webhook_url, otp_expired, invalid_otp, otp_max_attempts_exceeded,
otp_action_mismatch, action_token_invalid, otp_required, email_not_verified,
otp_issuance_blocked

---

## Security Requirements (v2 Additions)

- OTP codes: never stored in DB, never logged, Redis only with TTL.
- Action tokens: short-lived (5 min), carry action claim, rejected on mismatch.
- otp_challenge tokens: grant zero access to protected routes.
- Client secrets: never store plaintext. sha256 only.
- Password reset tokens: never store plaintext. sha256 only.
- Webhook secrets: stored encrypted, never returned after registration.
- SSRF: reject private IP and localhost webhook URLs at registration.
- Audit log: append-only enforced in code. No UPDATE or DELETE ever.
- Last admin: serializable transaction or DB-level constraint on check.
- Erasure: cleans all OTP Redis keys for the erased user.

---

## What Not to Build in v2

Do not implement any of the following unless explicitly instructed:

- TOTP / WebAuthn / SMS OTP (deferred to v3)
- Full MFA enrollment framework (v3)
- Multi-tenancy activation (columns exist, logic inactive)
- Retention purge scheduling (function exists, scheduling is v3)
- Scope enforcement beyond role-based (ABAC is v3)
- Consent management for third-party OAuth apps
- External email provider integration (Mailhog only in v2)